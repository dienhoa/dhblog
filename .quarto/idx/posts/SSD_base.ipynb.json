{"title":"Object Detection from scratch - Single Shot Detector","markdown":{"yaml":{"title":"Object Detection from scratch - Single Shot Detector","author":"Dien-Hoa Truong","date":"2022-09-15","categories":["computer-vision","deeplearning"]},"headingText":"Object Detection Dataloaders","containsRefs":false,"markdown":"\n\nBuilding an Object Detection from scratch with fastai v2\n\n![Object Detection](https://miro.medium.com/max/900/1*EYtn2YE7b6MTzMQyD2R3nA.jpeg)\n\nRecently, I had a project that needs to modify an Object Detection Architecture. However, when I searched for related repositories, I found it quite difficult to understand. We have a lot of libraries for use out of the box but hard to make changes to the source code.\n\nThis blog is the implementation of Single Shot Detector Architecture using fast.ai in [literate programming](https://en.wikipedia.org/wiki/Literate_programming) style so the readers can follow and run each line of code themselves in case needed to deepen their knowledge.\n\nThe original idea was taken from the fastai 2018 course. Readers are recommended to watch this lecture. [2018 Lecture](https://course18.fast.ai/lessons/lesson9.html)\n\n\nSome useful notes taken by students:\n- [Cedrick Note](https://github.com/cedrickchee/knowledge/blob/master/courses/fast.ai/deep-learning-part-2/2018-edition/lesson-9-multi-object-detection.md)\n- [Francesco Note](https://francescopochetti.com/fast-ai-dl2-lesson-9-single-shot-detection-detailed-walkthrough/)\n\nDataset used: Pascal 2017\n\n**What we can learn from this notebook:**\n\n- Object Detection DataLoaders from fastai `DataBlock` which contains Image, Bounding Box and Label. Understanding how the data resemble\n- Building Single Shot Detector (SSD) - Object Detection Model\n- Simple 4x4 Anchor Boxes. Relation between Receptive field and Anchor Boxes. \n- Loss function, Visualize Match to Ground-Truth\n- Classification Loss Discussion: Binary Cross Entropy and why Focal Loss is better \n- More Anchor Boxes: 3 layers of grids ( 4x4, 2x2, 1x1 ) with 9 variations (Zoom,Scale) / cell\n- Training and Results\n- Cleaning predictions with Non Maximum Supression (NMS)\n\n\nFor objection detection, you have:\n\n- 1 independent variable (X): Image\n- 2 dependents variables (Ys): Bounding box and Class  \n\nIn this part, we will use fastai `DataBlock` to build Object Detection `Dataloaders`. The idea is from each image file name, we will have:\n\n- An Image\n- Bounding Boxes getting from the annotations file\n- Labels correspond to each bounding box \n\n:::{.callout-note}\n\n- Zero padding: Each image have a different number of objects. Then, to make it possible to gather multiple images to one batch, the number of bounding boxes per image is the maximum in that batch (the padding value by default is 0) [bb_pad](https://docs.fast.ai/vision.data.html#bb_pad)\n- Background class: In Object Detection, we need to have a class that represents the background. `fastai` do it automatically for you by adding `#na#` at index 0\n- The coordinates of bounding box is rescaled to ~ -1 -> 1 in `fastai/vision/core.py` _scale_pnts\n\n:::\n\n\n( Check out some outputs below for details )\n\n![List of Files to Data](attachment:image2.png)\n\n:::{.callout-note}\n#na# is the background class as defined in `BBoxLblBlock`\n:::\n\n:::{.callout-note}\nThe coordinates of boudning box is rescaled to ~ -1 -> 1 in `fastai/vision/core.py`\n:::\n\n## Model Architecture\n\n![SSD Architecture](attachment:image3.png)\n\nIn a nutshell, Object Detection Model is a model that does 2 jobs at the same time: \n\n- a regressor with 4 outputs for bounding box\n- a classifier with `c` classes. \n\nTo handle multiple objects, here comes the grid cell. For each cell, you will have an atomic prediction for the object that dominates a part of the image ( This is the idea of the receptive field that you will see in the next part ) \n\n:::{.callout-tip}\n## My Intuition\n\nIn Machine Learning, it is better to improve from something rather than start from scratch. You can see this in: Image Classification Architecture - Resnet with the `Skip Connections`, or Gradient Boosting in Tree-based Model. There is a common point in the grid-cell SSD architecture, the model will try to improve from an `anchor box` rather than searching through the whole image.\n\n:::\n\nWe should better leverage a well-known pretrained classification model to be used as a backbone / or body ( resnet in this tutorial ) if the object is similar to the Imagenet dataset. The head part will follow to adapt to the necessary dimension\n\nTo easily develop the idea - visualize and debug, we will start with a simple 4x4 grid\n\nWe start with k = 1 which is the number of alterations for each anchor box ( we have a lot of anchor boxes later ) \n\nTo understand and verify that everything works ok, you can take out a batch and run the model on it\n\n**Shape explanation**:\n\n- 128: batch size\n- 16: number of anchor boxes\n- 21: number of classes\n- 4: number of bounding box coordinates\n\n## 4x4 Anchor boxes and Receptive Field\n\nAs mentioned before, we will start with a 4x4 grid to better visualize the idea. The size will be normalized to [0,1]\n\nThe idea of why, after the Body, we use Conv2d and not Linear Layer to make a 4x4x(4+c) output dimension instead of 16x(4+c) shape is - Receptive Field. This way, each cell will have information that comes directly from the location corresponding to the anchor box. The illustration is below. \n\n![SSD vs YOLO](https://miro.medium.com/max/1000/1*fPHmCosDHcrHmtKvWFK9Mg.png)\n\n![Receptive Field](https://theaisummer.com/static/490be17ee7f19b78003c3fdf5a6bbafc/83b75/receptive-field-in-convolutional-networks.png)\n\n:::{.callout-warning}\n            \nBe very careful about the bounding box format when working with Object Detection. There are many different formats out there. For example:\n\n- pascal_voc: [x_min, y_min, x_max, y_max]\n- coco: [x_min, y_min, width, height]\n- YOLO: [x_center, y_center, width, height]\n\nThe bounding box format in this tutorial is [x_min, y_min, x_max, y_max]\n\n:::\n\nCheck out [Bounding Boxes Augmentation](https://albumentations.ai/docs/getting_started/bounding_boxes_augmentation/) for more details: \n\nWe define the anchors coordinates as below\n\n## Visualization Utils\n\nIt is very helpful (to understand/ debug) when you can visualize data of every step. Many subtle tiny details happen in this Object Detection Problem. One careless implementation can lead to hours (or even days) to debug. Sometimes, you just wish that the code throws you some bugs that you can trackback. \n\n:::{.callout-warning}\n\nThere are some details that you need to double check\n\n- Are your ground truth bounding boxes, anchor boxes, bounding box activations are in the same scale ( -1 -> 1 or 0 -> 1 ) ?\n- Do the background class is handled correctly? ( This is a bug when I develop this notebook that the old version of the fastai course set the index of background as `number_of_classes` but in the latest version, it is 0 )\n- Do you map correctly each Anchor Box to the ground-true object? (This will be shown in the next session)\n\n:::\n\n:::{.callout-note}\n\nDon't hesitate to take out one batch from your dataloader and verify every single detail. When I start to use fast.ai, I made a big mistake that thinking these data are already processed and we can not show things directly from there. This data is very important, it is the input of your model. It must be carefully double-checked.\n\n:::\n\nBelow we will try to plot some images from a batch with their bounding boxes and classes, to see that we did not missing anything \n\n### Showing one batch\n\nExtracting one batch for your dataloader and see if the data is OK \n\nBecause the bounding box in the dataloader is scaled to -1 -> 1, it needs to be rescaled to 0 -> 1 for drawing by doing (bb+1)/2*Size\n\nEverything looks fine! We have correct bounding boxes and their corresponding classes\n\n## Map to Ground-Truth and Loss function\n\nAs you might guess, There are 2 components forming the Object Detection Loss: Classification Loss (For the class) and Localization Loss (For the bounding box)\n\nThe idea is, for each image, we will: \n- Calculate the Intersection-over-Union (IoU) of each predefined Anchor Box with the Object Bounding Box. \n- Assign the label for each cell (Map to ground truth) according to the IoUs. **Background** will be assigned to Cell which overlaps with no object\n- Calculate the Classification Loss for all Cells\n- Calculate the Bounding Box Location Loss only for Cells responsible to Objects (no Background)\n- Take the sum of these 2 losses\n\n:::{.callout-note}\n\nCurrently, we will loop for each image in a batch to calculate its loss and then sum them all. I think we might have a better way to vectorize these operations, or, calculate everything in one shot directly with a batch tensor\n\n:::\n\n\n![Map to Grouth Truth](attachment:image6.png)\n\nWe can see that all the zero values are removed before continuing to process\n\nThe Activations are passed to a Tanh function to rescale their values to -1 -> 1. Then they are processed to make coherent with the Grid Coordinates:\n\n- The center of each cell's prediction stays in the cell\n- The size of each cell's prediction can be varied from 1/2 to 3/2 cell's size to give more flexibility \n\n\n:::{.callout-tip}\n\nThe bounding box activations are in [x_center, y_center, width, height] format to easily define the min/max scale to the anchor box  \n\n:::\n\n`Map to Ground Truth` (Visualization below). The idea is looping through all anchor boxes and calculating the overlaps with the `Ground Truth` bounding boxes, then assigning each Anchor Box to the corresponding class\n\nFor calculating loss, we will loop through every images in a batch and calculate loss for each image (ssd_1_loss), then summing the result with ssd_loss. The Classification Loss (loss_f) currently is left empty as we will discussion it later in the next section.\n\n### Showing Map To Ground Truth\n\nAs mentioned earlier, Map-to-Ground-Truth is a very important step for calculating loss. We should show it to make sure everything looks fine\n\n### Classificaton Loss: Binary Cross Entropy and why Focal Loss\n\n2 tricks can be used for Classification Loss:\n\n- Binary Cross-Entropy Loss without background\n- Further improve Binary Cross-Entropy Loss with Focal Loss\n\n1. Binary Cross-Entropy\n\n- If we treat the Background Class as one class and ask the Model to understand what is a Background, it might be too difficult. We can translate it to a set of easier questions: Is it a Cat? Is it a Dog? ... through all the classes, which is exactly what Binary Cross-Entropy does\n\n2. Focal Loss\n\n- The classification task in object detection is very imbalance that we have a lot of background objects (check the Match to Ground-Truth image above). If we just use Binary Cross-Entropy Loss function, it will try all efforts to improve background classification\n\n![Focal Loss vs Binary Cross Entropy Loss](attachment:image7.png)\n\nQuote from fastai2018 course:\n\n\n*The blue line is the binary cross entropy loss. If the answer is not a motorbike, and I said “I think it’s not a motorbike and I am 60% sure” with the blue line, the loss is still about 0.5 which is pretty bad. So if we want to get our loss down, then for all these things which are actually back ground, we have to be saying “I am sure that is background”, “I am sure it’s not a motorbike, or a bus, or a person” — because if I don’t say we are sure it is not any of these things, then we still get loss.*\n\n*That is why the motorbike example did not work. Because even when it gets to lower right corner and it wants to say “I think it’s a motorbike”, there is no payoff for it to say so. If it is wrong, it gets killed. And the vast majority of the time, it is background. Even if it is not background, it is not enough just to say “it’s not background” — you have to say which of the 20 things it is.*\n\n*So the trick is to trying to find a different loss function that looks more like the purple line. Focal loss is literally just a scaled cross entropy loss. Now if we say “I’m .6 sure it’s not a motorbike” then the loss function will say “good for you! no worries”.*\n\nThe ssd_loss will loop through every image in a batch and accumulate loss \n\n## Training Simple Model\n\nThe loss decreases, and the model can learn something. Looking at the results shown below, we can see that the predictions are not so bad but not particularly good either. In the next session, we can see how to improve the results with more anchor boxes\n\n### Show Results\n\n## More anchors \n\nAs said earlier, the anchor box is a hint for the model to not go too far and focus on a part of the image. So obviously, 4x4 grid is not enough to predict an object of any size. In this part, by adding more `Conv2d` layers, we will have 3 grids: 4x4, 2x2, 1x1 and each cell will have 9 variations: 3-zooms and 3-ratios\n\nThe total number of anchors is: (16 + 4 + 1) x 9 = 189 anchors\n\n![image8.png](attachment:image8.png)\n\nWe need to adjust the SSD head a little bit. We will add more `Conv2D` layer with `StdConv` (to create 2x2 and 1x1 grids). After each `StdConv` is an `OutConv` to handle the Classification prediction and Localization prediction\n\n### Show results\n\nThe result looks better than the simple version above\n\n## Non Maximum Suppression (NMS)\n\nYou can see in the previous results, that having a lot of Anchor Boxes leads to many overlaps. You can use Non Maximum Suppression, a technique to choose one bounding box out of many overlapping ones\n","srcMarkdownNoYaml":"\n\nBuilding an Object Detection from scratch with fastai v2\n\n![Object Detection](https://miro.medium.com/max/900/1*EYtn2YE7b6MTzMQyD2R3nA.jpeg)\n\nRecently, I had a project that needs to modify an Object Detection Architecture. However, when I searched for related repositories, I found it quite difficult to understand. We have a lot of libraries for use out of the box but hard to make changes to the source code.\n\nThis blog is the implementation of Single Shot Detector Architecture using fast.ai in [literate programming](https://en.wikipedia.org/wiki/Literate_programming) style so the readers can follow and run each line of code themselves in case needed to deepen their knowledge.\n\nThe original idea was taken from the fastai 2018 course. Readers are recommended to watch this lecture. [2018 Lecture](https://course18.fast.ai/lessons/lesson9.html)\n\n\nSome useful notes taken by students:\n- [Cedrick Note](https://github.com/cedrickchee/knowledge/blob/master/courses/fast.ai/deep-learning-part-2/2018-edition/lesson-9-multi-object-detection.md)\n- [Francesco Note](https://francescopochetti.com/fast-ai-dl2-lesson-9-single-shot-detection-detailed-walkthrough/)\n\nDataset used: Pascal 2017\n\n**What we can learn from this notebook:**\n\n- Object Detection DataLoaders from fastai `DataBlock` which contains Image, Bounding Box and Label. Understanding how the data resemble\n- Building Single Shot Detector (SSD) - Object Detection Model\n- Simple 4x4 Anchor Boxes. Relation between Receptive field and Anchor Boxes. \n- Loss function, Visualize Match to Ground-Truth\n- Classification Loss Discussion: Binary Cross Entropy and why Focal Loss is better \n- More Anchor Boxes: 3 layers of grids ( 4x4, 2x2, 1x1 ) with 9 variations (Zoom,Scale) / cell\n- Training and Results\n- Cleaning predictions with Non Maximum Supression (NMS)\n\n## Object Detection Dataloaders\n\nFor objection detection, you have:\n\n- 1 independent variable (X): Image\n- 2 dependents variables (Ys): Bounding box and Class  \n\nIn this part, we will use fastai `DataBlock` to build Object Detection `Dataloaders`. The idea is from each image file name, we will have:\n\n- An Image\n- Bounding Boxes getting from the annotations file\n- Labels correspond to each bounding box \n\n:::{.callout-note}\n\n- Zero padding: Each image have a different number of objects. Then, to make it possible to gather multiple images to one batch, the number of bounding boxes per image is the maximum in that batch (the padding value by default is 0) [bb_pad](https://docs.fast.ai/vision.data.html#bb_pad)\n- Background class: In Object Detection, we need to have a class that represents the background. `fastai` do it automatically for you by adding `#na#` at index 0\n- The coordinates of bounding box is rescaled to ~ -1 -> 1 in `fastai/vision/core.py` _scale_pnts\n\n:::\n\n\n( Check out some outputs below for details )\n\n![List of Files to Data](attachment:image2.png)\n\n:::{.callout-note}\n#na# is the background class as defined in `BBoxLblBlock`\n:::\n\n:::{.callout-note}\nThe coordinates of boudning box is rescaled to ~ -1 -> 1 in `fastai/vision/core.py`\n:::\n\n## Model Architecture\n\n![SSD Architecture](attachment:image3.png)\n\nIn a nutshell, Object Detection Model is a model that does 2 jobs at the same time: \n\n- a regressor with 4 outputs for bounding box\n- a classifier with `c` classes. \n\nTo handle multiple objects, here comes the grid cell. For each cell, you will have an atomic prediction for the object that dominates a part of the image ( This is the idea of the receptive field that you will see in the next part ) \n\n:::{.callout-tip}\n## My Intuition\n\nIn Machine Learning, it is better to improve from something rather than start from scratch. You can see this in: Image Classification Architecture - Resnet with the `Skip Connections`, or Gradient Boosting in Tree-based Model. There is a common point in the grid-cell SSD architecture, the model will try to improve from an `anchor box` rather than searching through the whole image.\n\n:::\n\nWe should better leverage a well-known pretrained classification model to be used as a backbone / or body ( resnet in this tutorial ) if the object is similar to the Imagenet dataset. The head part will follow to adapt to the necessary dimension\n\nTo easily develop the idea - visualize and debug, we will start with a simple 4x4 grid\n\nWe start with k = 1 which is the number of alterations for each anchor box ( we have a lot of anchor boxes later ) \n\nTo understand and verify that everything works ok, you can take out a batch and run the model on it\n\n**Shape explanation**:\n\n- 128: batch size\n- 16: number of anchor boxes\n- 21: number of classes\n- 4: number of bounding box coordinates\n\n## 4x4 Anchor boxes and Receptive Field\n\nAs mentioned before, we will start with a 4x4 grid to better visualize the idea. The size will be normalized to [0,1]\n\nThe idea of why, after the Body, we use Conv2d and not Linear Layer to make a 4x4x(4+c) output dimension instead of 16x(4+c) shape is - Receptive Field. This way, each cell will have information that comes directly from the location corresponding to the anchor box. The illustration is below. \n\n![SSD vs YOLO](https://miro.medium.com/max/1000/1*fPHmCosDHcrHmtKvWFK9Mg.png)\n\n![Receptive Field](https://theaisummer.com/static/490be17ee7f19b78003c3fdf5a6bbafc/83b75/receptive-field-in-convolutional-networks.png)\n\n:::{.callout-warning}\n            \nBe very careful about the bounding box format when working with Object Detection. There are many different formats out there. For example:\n\n- pascal_voc: [x_min, y_min, x_max, y_max]\n- coco: [x_min, y_min, width, height]\n- YOLO: [x_center, y_center, width, height]\n\nThe bounding box format in this tutorial is [x_min, y_min, x_max, y_max]\n\n:::\n\nCheck out [Bounding Boxes Augmentation](https://albumentations.ai/docs/getting_started/bounding_boxes_augmentation/) for more details: \n\nWe define the anchors coordinates as below\n\n## Visualization Utils\n\nIt is very helpful (to understand/ debug) when you can visualize data of every step. Many subtle tiny details happen in this Object Detection Problem. One careless implementation can lead to hours (or even days) to debug. Sometimes, you just wish that the code throws you some bugs that you can trackback. \n\n:::{.callout-warning}\n\nThere are some details that you need to double check\n\n- Are your ground truth bounding boxes, anchor boxes, bounding box activations are in the same scale ( -1 -> 1 or 0 -> 1 ) ?\n- Do the background class is handled correctly? ( This is a bug when I develop this notebook that the old version of the fastai course set the index of background as `number_of_classes` but in the latest version, it is 0 )\n- Do you map correctly each Anchor Box to the ground-true object? (This will be shown in the next session)\n\n:::\n\n:::{.callout-note}\n\nDon't hesitate to take out one batch from your dataloader and verify every single detail. When I start to use fast.ai, I made a big mistake that thinking these data are already processed and we can not show things directly from there. This data is very important, it is the input of your model. It must be carefully double-checked.\n\n:::\n\nBelow we will try to plot some images from a batch with their bounding boxes and classes, to see that we did not missing anything \n\n### Showing one batch\n\nExtracting one batch for your dataloader and see if the data is OK \n\nBecause the bounding box in the dataloader is scaled to -1 -> 1, it needs to be rescaled to 0 -> 1 for drawing by doing (bb+1)/2*Size\n\nEverything looks fine! We have correct bounding boxes and their corresponding classes\n\n## Map to Ground-Truth and Loss function\n\nAs you might guess, There are 2 components forming the Object Detection Loss: Classification Loss (For the class) and Localization Loss (For the bounding box)\n\nThe idea is, for each image, we will: \n- Calculate the Intersection-over-Union (IoU) of each predefined Anchor Box with the Object Bounding Box. \n- Assign the label for each cell (Map to ground truth) according to the IoUs. **Background** will be assigned to Cell which overlaps with no object\n- Calculate the Classification Loss for all Cells\n- Calculate the Bounding Box Location Loss only for Cells responsible to Objects (no Background)\n- Take the sum of these 2 losses\n\n:::{.callout-note}\n\nCurrently, we will loop for each image in a batch to calculate its loss and then sum them all. I think we might have a better way to vectorize these operations, or, calculate everything in one shot directly with a batch tensor\n\n:::\n\n\n![Map to Grouth Truth](attachment:image6.png)\n\nWe can see that all the zero values are removed before continuing to process\n\nThe Activations are passed to a Tanh function to rescale their values to -1 -> 1. Then they are processed to make coherent with the Grid Coordinates:\n\n- The center of each cell's prediction stays in the cell\n- The size of each cell's prediction can be varied from 1/2 to 3/2 cell's size to give more flexibility \n\n\n:::{.callout-tip}\n\nThe bounding box activations are in [x_center, y_center, width, height] format to easily define the min/max scale to the anchor box  \n\n:::\n\n`Map to Ground Truth` (Visualization below). The idea is looping through all anchor boxes and calculating the overlaps with the `Ground Truth` bounding boxes, then assigning each Anchor Box to the corresponding class\n\nFor calculating loss, we will loop through every images in a batch and calculate loss for each image (ssd_1_loss), then summing the result with ssd_loss. The Classification Loss (loss_f) currently is left empty as we will discussion it later in the next section.\n\n### Showing Map To Ground Truth\n\nAs mentioned earlier, Map-to-Ground-Truth is a very important step for calculating loss. We should show it to make sure everything looks fine\n\n### Classificaton Loss: Binary Cross Entropy and why Focal Loss\n\n2 tricks can be used for Classification Loss:\n\n- Binary Cross-Entropy Loss without background\n- Further improve Binary Cross-Entropy Loss with Focal Loss\n\n1. Binary Cross-Entropy\n\n- If we treat the Background Class as one class and ask the Model to understand what is a Background, it might be too difficult. We can translate it to a set of easier questions: Is it a Cat? Is it a Dog? ... through all the classes, which is exactly what Binary Cross-Entropy does\n\n2. Focal Loss\n\n- The classification task in object detection is very imbalance that we have a lot of background objects (check the Match to Ground-Truth image above). If we just use Binary Cross-Entropy Loss function, it will try all efforts to improve background classification\n\n![Focal Loss vs Binary Cross Entropy Loss](attachment:image7.png)\n\nQuote from fastai2018 course:\n\n\n*The blue line is the binary cross entropy loss. If the answer is not a motorbike, and I said “I think it’s not a motorbike and I am 60% sure” with the blue line, the loss is still about 0.5 which is pretty bad. So if we want to get our loss down, then for all these things which are actually back ground, we have to be saying “I am sure that is background”, “I am sure it’s not a motorbike, or a bus, or a person” — because if I don’t say we are sure it is not any of these things, then we still get loss.*\n\n*That is why the motorbike example did not work. Because even when it gets to lower right corner and it wants to say “I think it’s a motorbike”, there is no payoff for it to say so. If it is wrong, it gets killed. And the vast majority of the time, it is background. Even if it is not background, it is not enough just to say “it’s not background” — you have to say which of the 20 things it is.*\n\n*So the trick is to trying to find a different loss function that looks more like the purple line. Focal loss is literally just a scaled cross entropy loss. Now if we say “I’m .6 sure it’s not a motorbike” then the loss function will say “good for you! no worries”.*\n\nThe ssd_loss will loop through every image in a batch and accumulate loss \n\n## Training Simple Model\n\nThe loss decreases, and the model can learn something. Looking at the results shown below, we can see that the predictions are not so bad but not particularly good either. In the next session, we can see how to improve the results with more anchor boxes\n\n### Show Results\n\n## More anchors \n\nAs said earlier, the anchor box is a hint for the model to not go too far and focus on a part of the image. So obviously, 4x4 grid is not enough to predict an object of any size. In this part, by adding more `Conv2d` layers, we will have 3 grids: 4x4, 2x2, 1x1 and each cell will have 9 variations: 3-zooms and 3-ratios\n\nThe total number of anchors is: (16 + 4 + 1) x 9 = 189 anchors\n\n![image8.png](attachment:image8.png)\n\nWe need to adjust the SSD head a little bit. We will add more `Conv2D` layer with `StdConv` (to create 2x2 and 1x1 grids). After each `StdConv` is an `OutConv` to handle the Classification prediction and Localization prediction\n\n### Show results\n\nThe result looks better than the simple version above\n\n## Non Maximum Suppression (NMS)\n\nYou can see in the previous results, that having a lot of Anchor Boxes leads to many overlaps. You can use Non Maximum Suppression, a technique to choose one bounding box out of many overlapping ones\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"output-file":"SSD_base.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","theme":"litera","title-block-banner":true,"title":"Object Detection from scratch - Single Shot Detector","author":"Dien-Hoa Truong","date":"2022-09-15","categories":["computer-vision","deeplearning"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}